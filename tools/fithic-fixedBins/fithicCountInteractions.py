#!/bin/python
######################################
# Generate contact maps from bam files 
# and fragment lists
#
# Author: Fabian Buske (28/11/2014)
######################################

import os, sys, re
import traceback
from optparse import OptionParser
import fileinput
import datetime
from quicksect import IntervalTree
import gzip

######################################
# Read
######################################

class Read():
    def __init__(self, read):

        if (read==""):
            self.seq=""
            self.qname="dummy"
            self.is_unmapped=True
            self.tid=None
            self.is_read1=None
            self.is_reverse=None
        else:
            self.is_duplicate=read.is_duplicate
            self.is_unmapped=read.is_unmapped
            self.tid=read.tid
            self.qname=read.qname
            self.is_read1=True
            if (read.is_read2):
                self.is_read1=False
            self.is_reverse=read.is_reverse
            self.alen=read.alen
            self.pos=read.pos


    def check(self):
        if(self.is_reverse):
            self.revcomp()

    def isPair(self,number):
        if(self.is_read1 and number==0):
            return True
        if(not(self.is_read1) and number==1):
            return True
        print("Reads not paired up correctly: paired/single ended? not namesorted?")
        print(str(self)+" "+str(number))

    def __str__(self): 
        if(self.is_unmapped):
            return "%s read1 %s %s" % (self.qname,self.is_read1, self.seq)
        else:
            return "%s read1 %s %s %i %i" % (self.qname,self.is_read1, self.tid, self.pos,self.alen)

    def revcomp(self):
        basecomplement = {'N':'N','A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'}
        rc=""
        for i in reversed(self.seq):
            rc+=basecomplement[i]
        self.seq=rc


    def getInfo(self, string):
        for i in self.tags:
            if( i[0]==string):
                return i[1]

######################################
# Interval
######################################
class Interval():
    def __init__(self, chrom, start, end):
        self.chrom=chrom
        self.start=start
        self.end=end

######################################
# Timestamp
######################################
def timeStamp():
    return datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S').format()


# manage option and arguments processing
def main():
    global options
    global args
    usage = '''usage: %prog [options] [bamFile]+
    
    generates (single locus) fragmentCounts and (pairwise) contactCount files
    for a (set of) aligned files.
    NOTE: If multiple libraries are input they are simply pooled, i.e. read-pairs are 
          summed across all libraries - this may bias results to a libraries sequenced deeper)
    '''
    parser = OptionParser(usage)
    parser.add_option("-q", "--quiet", action="store_false", dest="verbose", default=True,
                    help="don't print status messages to stdout")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,
                    help="print status messages to stdout")
    parser.add_option("-V", "--veryverbose", action="store_true", dest="vverbose", default=False,
                    help="print lots of status messages to stdout")
    parser.add_option("-M", "--multicount", action="store_true", dest="multicount", default=True,
                    help="count read that maps onces for each fragment it maps to (potentially several)")
    parser.add_option("-g", "--genomeFragmentFile", type="string", dest="fragmentFile", default="", 
                    help="file containing the genome fragments after digestion with the restriction enzyme(s), generated by hicup")
    parser.add_option("-f", "--fragmentAggregation", type="int", dest="fragmentAggregation", default=1, 
                    help="number of restriction enzyme fragments to concat")
    parser.add_option("-r", "--resolution", type=int, dest="resolution", default=1000000, 
                    help="size of a fragment in bp if no genomeFragmentFile is given")
    parser.add_option("-c", "--chromsizes", type="string", dest="chromSizes", default="", 
                    help="tab separated file containing chromosome sizes")
    parser.add_option("-C", "--chrompattern", type="string", dest="chromPattern", default="", 
                    help="pattern of chromosomes to filter for [default all]")
    parser.add_option("-m", "--mappability", type="string", dest="mappability", default="", 
                    help="bigwig containing mappability score for a given tag size")
    parser.add_option("-o", "--outputDir", type="string", dest="outputDir", default="", 
                    help="output directory [default: %default]")
    parser.add_option("-n", "--outputFilename", type="string", dest="outputFilename", default="", 
                    help="output filename [default: extracted from first input file")
    parser.add_option("-t", "--tmpDir", type="string", dest="tmpDir", default="/tmp", 
                    help="directory for temp files [default: %default]")
    parser.add_option("-s", "--sep", type="string", dest="separator", default=" ",
                    help="delimiter to use when reading the input [default: %default]")
    parser.add_option("--create2DMatrix", action="store_true", dest="create2DMatrix", default=False,
                    help="create a tab separated 2D matrix file")
    parser.add_option("--create2DMatrixPerChr", action="store_true", dest="create2DMatrixPerChr", default=False,
                    help="create a tab separated 2D matrix file one per Chromosome")
    parser.add_option("--inputIsFragmentPairs", action="store_true", dest="inputIsFragmentPairs", default=False,
                    help="input is a gzipped fragment pair file rather than bam files")
    parser.add_option("--inputIsReadPairs", type="string", dest="inputIsReadPairs", default="",
                    help="gzipped files with mapped read pair information, requires 4 column identifier corresponding to chrA,posA,chrB,posB,chrPrefix (separated buy comma), e.g. 2,3,6,7,chr")
     
   
    
    (options, args) = parser.parse_args()
    if (len(args) < 1):
        parser.print_help()
        parser.error("[ERROR] Incorrect number of arguments, need a dataset")
    
    if (options.fragmentAggregation < 1):
        parser.error("[ERROR] fragmentAggregation must be a positive integer, was :"+str(options.fragmentAggregation))
        sys.exit(1)
    
    if (options.fragmentFile != ""):
        if (not os.path.isfile(options.fragmentFile)):
            parser.error("[ERROR] fragmentFile does not exist, was :"+str(options.fragmentFile))
            sys.exit(1)

    else:
        if (options.resolution < 1):
            parser.error("[ERROR] resolution must be a positive integer, was :"+str(options.resolution))
            sys.exit(1)
        elif (options.chromSizes == "" or not os.path.isfile(options.chromSizes)):
            parser.error("[ERROR] chromSizes not given or not existing, was :"+str(options.chromSizes))
            sys.exit(1)
        
    if (options.outputDir != ""): 
        options.outputDir += os.sep
    
    if (options.inputIsReadPairs != ""):
    	if (len(options.inputIsReadPairs.split(",")) < 4 or len(options.inputIsReadPairs.split(",")) > 5):
            parser.error("[ERROR] inputIsReadPairs does not have 4 column indexes :"+str(options.inputIsReadPairs))
            sys.exit(1)
        elif (options.inputIsFragmentPairs):
            parser.error("[ERROR] inputIsFragmentPairs and inputIsReadPairs cannot be set at the same time")
            sys.exit(1)
    
    if (options.verbose):
        print >> sys.stdout, "fragmentFile:          %s" % (options.fragmentFile)
        print >> sys.stdout, "fragmentAggregation:   %s" % (options.fragmentAggregation)
        print >> sys.stdout, "resolution:            %s" % (options.resolution)
        print >> sys.stdout, "chromSizes:            %s" % (options.chromSizes)
        print >> sys.stdout, "outputDir:             %s" % (options.outputDir)
        print >> sys.stdout, "tmpDir:                %s" % (options.tmpDir)
    
    process()

def createIntervalTreesFragmentResolution():
    ''' 
    creates one interval tree for quick lookups
    returns 
        fragmentsMap[fragmentId] = [tuple(chrom, fragmentMidPoint)]
        intersect_tree - intersect Tree for interval matching
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : populate intervaltree with given resolution for chromosomes matching pattern %s" % (timeStamp(), options.chromPattern)
    
    intersect_tree = IntervalTree()
    fragmentsCount = 0
    fragmentsMap = {}
    fragmentsChrom = {} # lookp table for fragment ranges of a chromosome

    for line in fileinput.input([options.chromSizes]):
        chrom=line.split("\t")[0]
        # check if chromosome needs to be filtered out or not
        if (options.chromPattern != "" and not re.match("^"+options.chromPattern+"$", chrom)):
            # skip this one
            if (options.vverbose):
                print "skipping pattern %s" % (line)
            continue

        fragmentsStart=fragmentsCount
        chromlen=int(line.split("\t")[1])

        for i in range(0, chromlen, options.resolution):
            start=i
            end=min(i+ options.resolution, chromlen)
            interval = Interval(chrom, start, end)
            intersect_tree.insert(interval, fragmentsCount)
            fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
            fragmentsCount += 1
            if (options.vverbose):
                print >> sys.stdout, "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
        
        fragmentsEnd=fragmentsCount
        fragmentsChrom[chrom] = tuple([fragmentsStart, fragmentsEnd])
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: intervaltree populated" % (timeStamp())
    
    return [ fragmentsMap, intersect_tree, fragmentsCount, fragmentsChrom ]
    
def createIntervalTreesFragmentFile():
    ''' 
        creates one interval tree for quick lookups
        returns 
            fragmentsMap[fragmentId] = [tuple(chrom, fragmentMidPoint)]
            intersect_tree - intersect Tree for interval matching
        
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : populate intervaltree from fragmented genome" % (timeStamp())
    
    intersect_tree = IntervalTree()
    fragmentsCount = 0
    fragmentsMap = {}
    fragmentsChrom = {} # lookp table for fragment ranges of a chromosome
    fragmentsStart = 0

    start = 0
    end = 0
    counter = 0
    chrom = ""
    
    for line in fileinput.input([options.fragmentFile]):
        line = line.strip()
        if (len(line)==0 or line.startswith("Genome") or line.startswith("Chromosome")):
            continue
            
        cols = line.split("\t")
        try:
            # check if chromosome changed from last
            if (cols[0] != chrom):
                # do we have do finish the last chromosome?
                if (end > 0):
                    interval = Interval(chrom, start, end)
                    intersect_tree.insert(interval, fragmentsCount)
                    fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
                    fragmentsCount += 1

                    fragmentsChrom[chrom] = tuple([fragmentsStart, fragmentsCount]) 
                    fragmentsStart = fragmentsCount

                    if (options.vverbose):
                        print >> sys.stdout,  "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
                # check if chromosome needs to be filtered out or not
                if (options.chromPattern  != "" and not re.match(options.chromPattern, cols[0])):
                    chrom = ""
                    start = 0
                    end = 0

                else:
                    chrom = cols[0]
                    start = int(cols[1])
                    end = int(cols[2])
                counter = 0
    
            # check if fragment aggregation is fulfilled
            elif (counter >= options.fragmentAggregation):
                interval = Interval(chrom, start, end)
                intersect_tree.insert(interval, fragmentsCount)
                if (options.vverbose):
                    print >> sys.stdout,  "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
    
                fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
                start = int(cols[1])
                end = int(cols[2])
                counter = 0
                fragmentsCount += 1                
            else:
                end = int(cols[2])
                
            # increment counter
            counter += 1
        
        except:
            if (options.verbose):
                print >> sys.stderr, 'skipping line in options.fragmentFile: %s' % (line)
            if (options.vverbose):
                traceback.print_exc()
                sys.exit(1)
    
    
    # handle last fragment
    if (end > 0):
        interval = Interval(chrom, start, end)
        intersect_tree.insert(interval, fragmentsCount)
        fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
        fragmentsCount += 1
        fragmentsChrom[chrom] = tuple([fragmentsStart, fragmentsCount]) 

        if (options.vverbose):
            print >> sys.stdout, "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
    
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: intervaltree populated" % (timeStamp())
            
    return [fragmentsMap, intersect_tree, fragmentsCount, fragmentsChrom]

def getNext(iterator):
    ''' 
    get the next read and populate object
    '''
    
    try:
        return Read(iterator.next())
    except StopIteration:
        if (options.vverbose):
            traceback.print_exc()
        return Read("")
        
        
def findNextReadPair(samiter):
    ''' 
    find the next read pair
    '''
    readpair=[getNext(samiter), getNext(samiter)]
    
    while( re.sub('\/[1,2]$', '', readpair[0].qname) != re.sub('\/[1,2]$', '', readpair[1].qname)):
        if (options.verbose):
            print "[WARN] File: drop first from unpaired read %s %s" %(readpair[0].qname, readpair[1].qname)
        readpair.pop(0)
        readpair.append(getNext(samiter))
        
    return readpair
   
def find(interval, tree):
    ''' Returns a list with the overlapping intervals '''
    out = []
    tree.intersect( interval, lambda x: out.append(x) )
    return [ (x.start, x.end, x.linenum) for x in out ]
          

def getFragment(inputfile, read, intersect_tree, fragmentList):
    ''' When input is bam file '''
    fragmentID = -1
    try:
        # get fragments for both reads
        rchrom = inputfile.getrname(read.tid)
        rstart = read.pos
        rend =  read.pos+read.alen

        if (options.vverbose):
            print >> sys.stdout, "- Check   : read %s %d %d" % (rchrom, rstart, rend )
        
        interval = Interval(rchrom, rstart, rend)

        fragments = find(interval, intersect_tree)
        if (len(fragments) == 0 ):
            if (options.vverbose):
                print >> sys.stderr, '[WARN] no overlap found : %s (skipping)' % (read)    
            return
        elif (len(fragments)> 1):
            if (not options.multicount):
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s (skipping)' % (read)    
                return 
            else:
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s (multicounting %d times)' % (read, len(fragments))    
                
        for i in xrange(len(fragments)):
            #extract fragmentID
            fragmentID = fragments[i][2] # corresponds to linenum
            
            if (not fragmentList.has_key(fragmentID)):
                fragmentList[fragmentID] = 0
    
            fragmentList[fragmentID] += 1
        
    except:
        if (options.verbose):
            print >> sys.stderr, '[WARN] problems with interval intersection: %s (skipping)' % (read)        
            traceback.print_exc()
            sys.exit(1)
        if (options.vverbose):
            traceback.print_exc()
            sys.exit(1)
            
    return fragmentID

def mapFragment(rchrom, rstart, intersect_tree, fragmentList):
    ''' When input is fragment pair file '''
    fragmentID = -1
    try:
        # get fragments for both reads
        rend =  rstart+1

        if (options.vverbose):
            print >> sys.stdout, "- Check   : fragment %s %d %d" % (rchrom, rstart, rend )
        
        interval = Interval(rchrom, rstart, rend)

        fragments = find(interval, intersect_tree)
        if (len(fragments) == 0 ):
            if (options.vverbose):
                print >> sys.stderr, '[WARN] no overlap found : %s %d (skipping)' % (rchrom, rstart)
            return
        elif (len(fragments)> 1):
            if (not options.multicount):
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s %d (skipping)' % (rchrom, rstart)
                return 
            else:
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s %d (multicounting %d times)' % (rchrom, rstart, len(fragments))    
                
        for i in xrange(len(fragments)):
            #extract fragmentID
            fragmentID = fragments[i][2] # corresponds to linenum
            
            if (not fragmentList.has_key(fragmentID)):
                fragmentList[fragmentID] = 0
    
            fragmentList[fragmentID] += 1
        
    except:
        if (options.verbose):
            print >> sys.stderr, '[WARN] problems with interval intersection: %s %d (skipping)' % (rchrom, rstart)
            traceback.print_exc()
            sys.exit(1)
        if (options.vverbose):
            traceback.print_exc()
            sys.exit(1)
            
    return fragmentID

def countReadsPerFragment(intersect_tree):
    '''
        counts the reads per fragment and generates appropriate output files
    '''
    
    fragmentList = {}
    fragmentPairs = {}
    
    if (options.inputIsFragmentPairs):
        for fFile in xrange(len(args)):
            if (options.verbose):
                print >> sys.stdout, "- %s START   : processing fragment files: %s" % (timeStamp(), args[fFile])

            with gzip.open(args[fFile]) as infile:
                for line in infile:
                    (chr1, start1, chr2, start2, count) = line.strip().split("\t")
                    
                    fragmentID1 = mapFragment(chr1, int(start1), intersect_tree, fragmentList)
                    fragmentID2 = mapFragment(chr2, int(start2), intersect_tree, fragmentList)

                    if (fragmentID1 == None or fragmentID2 == None):
                        if (options.vverbose):
                            print >> sys.stdout, "-- one region does not co-occur with any fragment: %s %s" % (fragmentID1, fragmentID2)
                        continue
                
                    f_tuple = tuple([min(fragmentID1, fragmentID2), max(fragmentID1, fragmentID2)])
                    if (not fragmentPairs.has_key(f_tuple)):
                        fragmentPairs[f_tuple] = 0
                    fragmentPairs[f_tuple] += int(count)

            if (options.verbose):
                print >> sys.stdout, "- %s FINISHED: getting counts form fragment files " % (timeStamp())

    if (options.inputIsReadPairs != ""):
       # get column indexes
       chr_index = map(int,  options.inputIsReadPairs.split(",")[0:4])
       try:
            chr_prefix=options.inputIsReadPairs.split(",")[4]
       except:
            chr_prefix=""

       for fFile in xrange(len(args)):
            if (options.verbose):
                print >> sys.stdout, "- %s START   : processing read files: %s" % (timeStamp(), args[fFile])

            with gzip.open(args[fFile]) as infile:
                for line in infile:
                    cols   = line.strip().split()
                    chr1   = chr_prefix + cols[chr_index[0]]
                    start1 = int(cols[chr_index[1]])
                    chr2   = chr_prefix + cols[chr_index[2]]
                    start2 = int(cols[chr_index[3]])
                    
                    fragmentID1 = mapFragment(chr1, start1, intersect_tree, fragmentList)
                    fragmentID2 = mapFragment(chr2, start2, intersect_tree, fragmentList)

                    if (fragmentID1 == None or fragmentID2 == None):
                        if (options.vverbose):
                            print >> sys.stdout, "-- one region does not co-occur with any fragment: %s %s" % (fragmentID1, fragmentID2)
                        continue
                
                    f_tuple = tuple([min(fragmentID1, fragmentID2), max(fragmentID1, fragmentID2)])
                    if (not fragmentPairs.has_key(f_tuple)):
                        fragmentPairs[f_tuple] = 0
                    fragmentPairs[f_tuple] += 1

            if (options.verbose):
                print >> sys.stdout, "- %s FINISHED: getting counts form read files " % (timeStamp())

    else:
        # lazy load
        import pysam
        for bamFile in xrange(len(args)):
            if (options.verbose):
                print >> sys.stdout, "- %s START   : processing reads from bam file: %s" % (timeStamp(), args[bamFile])

            samfile = pysam.Samfile(args[bamFile], "rb" )
        
            samiter = samfile.fetch(until_eof=True)
            
            readcounter = 0
            
            while(True):
                readpair = findNextReadPair(samiter)
                # if file contains any more reads, exit
                if (readpair[0].qname=="dummy"):
                    break
                
                fragmentID1 = getFragment(samfile, readpair[0], intersect_tree, fragmentList)
                fragmentID2 = getFragment(samfile, readpair[1], intersect_tree, fragmentList)
                
                if (fragmentID1 == None or fragmentID2 == None):
                    if (options.vverbose):
                        print >> sys.stdout, "-- one read does not co-occur with any fragment: %d %d" % (fragmentID1, fragmentID2)
                    continue
            
                f_tuple = tuple([min(fragmentID1, fragmentID2), max(fragmentID1, fragmentID2)])
                if (not fragmentPairs.has_key(f_tuple)):
                    fragmentPairs[f_tuple] = 0
                fragmentPairs[f_tuple] += 1
                readcounter+=1
                
                if (options.verbose and readcounter % 1000000 == 0 ):
                    print >> sys.stdout, "- %s         : %d read pairs processed" % (timeStamp(), readcounter)
            samfile.close()
        
            if (options.verbose):
                print >> sys.stdout, "- %s FINISHED: getting reads from bam file " % (timeStamp())

    return [ fragmentList, fragmentPairs ]    


def output(fragmentsMap , fragmentList, fragmentPairs, fragmentCount, fragmentsChrom):
    '''
    outputs 2 files, the first containing 
    "chr    extraField      fragmentMid     marginalizedContactCount        mappable? (0/1)"
    
    and the second containing:
    "chr1   fragmentMid1    chr2    fragmentMid2    contactCount"
    
    optionally output the 2D contact matrix
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : output data " % (timeStamp())

    if ( options.outputFilename != "" ):
        outfile1 = gzip.open(options.outputDir+options.outputFilename+".fragmentLists.gz","wb")
    else:
        outfile1 = gzip.open(options.outputDir+os.path.basename(args[0])+".fragmentLists.gz","wb")
    
    fragmentIds = fragmentsMap.keys()
    fragmentIds.sort()

    # lookup mean mappability ratio
    bw = ""
    if (options.mappability != ""):
        # lazy load
        from bx.intervals.io import GenomicIntervalReader
        from bx.bbi.bigwig_file import BigWigFile
        bw = BigWigFile( open( options.mappability ) )
    

    for fragmentId in fragmentIds:

        contactCounts = 0
        chrom = fragmentsMap[fragmentId][0]
        midpoint =  fragmentsMap[fragmentId][1]

        if (options.vverbose):
            print >> sys.stdout, "- process %s %d " % (chrom, midpoint)

        if (fragmentList.has_key(fragmentId)):
            contactCounts = fragmentList[fragmentId]
        
        if (bw != ""):    
            try:
                mappable = bw.query(chrom, midpoint-options.resolution/2, midpoint+options.resolution/2, 1)[0]["mean"]
            except:
                mappable = 0
                # problem with invalid values
                if (options.vverbose):
                    print >> sys.stderr, "Problem with bw file at %s %d-%d" % (chrom, midpoint-options.resolution/2, midpoint+options.resolution/2)
                    print traceback.format_exc()
                
        elif (contactCounts>0):
            mappable=1

        outfile1.write("%s\t%d\t%s\t%f\n" % (chrom, midpoint, "NA", mappable))
        
    outfile1.close()
    
    if ( options.outputFilename != "" ):
        outfile2 = gzip.open(options.outputDir+options.outputFilename+".contactCounts.gz","wb")
    else:
        outfile2 = gzip.open(options.outputDir+os.path.basename(args[0])+".contactCounts.gz","wb")
        
    for fragmentIds, contactCounts in fragmentPairs.iteritems():
        chrom1 = fragmentsMap[fragmentIds[0]][0]
        midpoint1 =  fragmentsMap[fragmentIds[0]][1]
    
        chrom2 = fragmentsMap[fragmentIds[1]][0]
        midpoint2 =  fragmentsMap[fragmentIds[1]][1]
    
        outfile2.write("%s\t%d\t%s\t%d\t%d\n" % (chrom1, midpoint1, chrom2, midpoint2, contactCounts))
        
    outfile2.close()
    
    if (options.create2DMatrix or options.create2DMatrixPerChr):
        # lazy loading
        from scipy.sparse import lil_matrix
        import numpy

        # populate sparse matrix
        A = lil_matrix((fragmentCount, fragmentCount), dtype='i')    
        for fragmentIds, contactCounts in fragmentPairs.iteritems():
            A[fragmentIds[0],fragmentIds[1]] = contactCounts
            A[fragmentIds[1],fragmentIds[0]] = contactCounts
        # convert to coordinate format 
        B = A.tocoo()
            
        if (options.create2DMatrix):

            if ( options.outputFilename != "" ):
                outfile3 = options.outputDir+options.outputFilename+".matrix"
            else:
                outfile3 = options.outputDir+os.path.basename(args[0])+".matrix"

            if (options.verbose):
                print >> sys.stdout, "- save 2Dmatrix to %s " % (outfile3)
            
            f_handle=open(outfile3,'w')
            
            C = B.tocsr()
            for i in xrange(fragmentCount):
                numpy.savetxt(f_handle, C[i].toarray(),fmt='%i', delimiter='\t')
                
            f_handle.close()

        if (options.create2DMatrixPerChr):
            for chr in fragmentsChrom.keys():

                C = B.tocsc()[:,fragmentsChrom[chr][0]:fragmentsChrom[chr][1]].tocsr()[fragmentsChrom[chr][0]:fragmentsChrom[chr][1],:]

                fragmentRange=fragmentsChrom[chr][1]-fragmentsChrom[chr][0]
                header=['d']+[ "%s%d" % i for i in zip(['r']*fragmentRange,range(fragmentRange))]
                
                if ( options.outputFilename != "" ):
                    outfile3 = options.outputDir+options.outputFilename+"."+chr+".matrix"
                else:
                    outfile3 = options.outputDir+os.path.basename(args[0])+"."+chr+".matrix"

                if (options.verbose):
                    print >> sys.stdout, "- save 2Dmatrix for chromosome %s to %s " % (chr, outfile3)
                
                f_handle=open(outfile3,'w')
                f_handle.write('\t'.join(header)+"\n")
                for i in xrange(fragmentRange):
                    f_handle.write(header[i+1]+"\t")
                    numpy.savetxt(f_handle, C[i].toarray(),fmt='%i', delimiter='\t')
                    
                f_handle.close()
            
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: output data" % (timeStamp())


def process():
    global options
    global args

    if (options.fragmentFile != ""):    
        [ fragmentsMap, intersectTree, fragmentCount, fragmentsChrom ] = createIntervalTreesFragmentFile()
    else:
        [ fragmentsMap, intersectTree, fragmentCount, fragmentsChrom ] = createIntervalTreesFragmentResolution()
        
    [ fragmentList, fragmentPairs ] = countReadsPerFragment(intersectTree)
    
    output(fragmentsMap, fragmentList, fragmentPairs, fragmentCount, fragmentsChrom)
    
######################################
# main
######################################
if __name__ == "__main__":
    main()

