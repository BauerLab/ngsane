#!/bin/python
######################################
# Generate contact maps from bam files 
# and fragment lists
#
# Author: Fabian Buske (13/05/2013)
######################################


import os, sys, re
import traceback
from optparse import OptionParser
import pysam
from quicksect import IntervalTree
import fileinput
import datetime

######################################
# Read
######################################

class Read():
    def __init__(self, read):

        if (read==""):
            self.seq=""
            self.qname="dummy"
            self.is_unmapped=True
            self.tid=None
            self.is_read1=None
            self.is_reverse=None
        else:
            self.is_duplicate=read.is_duplicate
            self.is_unmapped=read.is_unmapped
            self.tid=read.tid
            self.qname=read.qname
            self.is_read1=True
            if (read.is_read2):
                self.is_read1=False
            self.is_reverse=read.is_reverse
            self.alen=read.alen
            self.pos=read.pos


    def check(self):
        if(self.is_reverse):
            self.revcomp()

    def isPair(self,number):
        if(self.is_read1 and number==0):
            return True
        if(not(self.is_read1) and number==1):
            return True
        print("Reads not paired up correctly: paired/single ended? not namesorted?")
        print(str(self)+" "+str(number))

    def __str__(self): 
        if(self.is_unmapped):
            return "%s read1 %s %s" % (self.qname,self.is_read1, self.seq)
        else:
            return "%s read1 %s %s %i %i" % (self.qname,self.is_read1, self.tid, self.pos,self.alen)

    def revcomp(self):
        basecomplement = {'N':'N','A': 'T', 'C': 'G', 'G': 'C', 'T': 'A'}
        rc=""
        for i in reversed(self.seq):
            rc+=basecomplement[i]
        self.seq=rc


    def getInfo(self, string):
        for i in self.tags:
            if( i[0]==string):
                return i[1]

######################################
# Interval
######################################
class Interval():
    def __init__(self, chrom, start, end):
        self.chrom=chrom
        self.start=start
        self.end=end

######################################
# Timestamp
######################################
def timeStamp():
    return datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S').format()


# manage option and arguments processing
def main():
    global options
    global args
    usage = '''usage: %prog [options] [bamFile]+
    
    generates (single locus) fragmentCounts and (pairwise) contactCount files
    '''
    parser = OptionParser(usage)
    parser.add_option("-q", "--quiet", action="store_false", dest="verbose", default=True,
                    help="don't print status messages to stdout")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False,
                    help="print status messages to stdout")
    parser.add_option("-V", "--veryverbose", action="store_true", dest="vverbose", default=False,
                    help="print lots of status messages to stdout")
    parser.add_option("-M", "--multicount", action="store_true", dest="multicount", default=True,
                    help="count read that maps onces for each fragment it maps to (potentially several)")
    parser.add_option("-g", "--genomeFragmentFile", type="string", dest="fragmentFile", default="", 
                    help="file containing the genome fragments after digestion with the restriction enzyme(s), generated by hicup")
    parser.add_option("-f", "--fragmentAggregation", type="int", dest="fragmentAggregation", default=10, 
                    help="number of restriction enzyme fragments to concat")
    parser.add_option("-r", "--resolution", type=int, dest="resolution", default=1000000, 
                    help="size of a fragment in bp if no genomeFragmentFile is given")
    parser.add_option("-c", "--chromsizes", type="string", dest="chromSizes", default="", 
                    help="tab separated file containing chromosome sizes")
    parser.add_option("-C", "--chrompattern", type="string", dest="chromPattern", default="", 
                    help="pattern of chromosomes to filter for [default all]")
    parser.add_option("-m", "--mappability", type="string", dest="mappability", default="", 
                    help="bigwig containing mappability score for a given tag size")
    parser.add_option("-o", "--outputDir", type="string", dest="outputDir", default="", 
                    help="output directory [default: %default]")
    parser.add_option("-n", "--outputFilename", type="string", dest="outputFilename", default="", 
                    help="output filename [default: extracted from first input file")
    parser.add_option("-t", "--tmpDir", type="string", dest="tmpDir", default="/tmp", 
                    help="directory for temp files [default: %default]")
    parser.add_option("-D", "--create2DMatrix", action="store_true", dest="create2DMatrix", default=False,
                    help="create a tab separated 2D matrix file")
    
    
    (options, args) = parser.parse_args()
    if (len(args) < 1):
        parser.print_help()
        parser.error("[ERROR] Incorrect number of arguments, need a dataset")
    
    if (options.fragmentAggregation < 1):
        parser.error("[ERROR] fragmentAggregation must be a positive integer, was :"+str(options.fragmentAggregation))
        sys.exit(1)
    
    if (options.fragmentFile != ""):
        if (not os.path.isfile(options.fragmentFile)):
            parser.error("[ERROR] fragmentFile does not exist, was :"+str(options.fragmentFile))
            sys.exit(1)

    else:
        if (options.resolution < 1):
            parser.error("[ERROR] resolution must be a positive integer, was :"+str(options.resolution))
            sys.exit(1)
        elif (options.chromSizes == "" or not os.path.isfile(options.chromSizes)):
            parser.error("[ERROR] chromSizes not given or not existing, was :"+str(options.chromSizes))
            sys.exit(1)
        
    if (options.outputDir != ""): 
        options.outputDir += os.sep
    
    if (options.verbose):
        print >> sys.stdout, "fragmentFile:          %s" % (options.fragmentFile)
        print >> sys.stdout, "fragmentAggregation:   %s" % (options.fragmentAggregation)
        print >> sys.stdout, "resolution:            %s" % (options.resolution)
        print >> sys.stdout, "chromSizes:            %s" % (options.chromSizes)
        print >> sys.stdout, "outputDir:             %s" % (options.outputDir)
        print >> sys.stdout, "tmpDir:                %s" % (options.tmpDir)
    
    process()

def createIntervalTreesFragmentResolution():
    ''' 
    creates one interval tree for quick lookups
    returns 
        fragmentsMap[fragmentId] = [tuple(chrom, fragmentMidPoint)]
        intersect_tree - intersect Tree for interval matching
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : populate intervaltree with given resolution for chromosomes matching pattern %s" % (timeStamp(), options.chromPattern)
    
    intersect_tree = IntervalTree()
    fragmentsCount = 0
    fragmentsMap = {}
     
    for line in fileinput.input([options.chromSizes]):
        chrom=line.split("\t")[0]
        # check if chromosome needs to be filtered out or not
        if (options.chromPattern != "" and not re.match(options.chromPattern, chrom)):
            # skip this one
            if (options.vverbose):
                print "skipping pattern %s" % (line)
            continue
            
        chromlen=int(line.split("\t")[1])

        for i in range(0, chromlen, options.resolution):
            start=i
            end=min(i+ options.resolution, chromlen)
            interval = Interval(chrom, start, end)
            intersect_tree.insert(interval, fragmentsCount)
            fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
            fragmentsCount += 1
            if (options.vverbose):
                print >> sys.stdout, "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
        
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: intervaltree populated" % (timeStamp())
    
    return [ fragmentsMap, intersect_tree, fragmentsCount ]
    
def createIntervalTreesFragmentFile():
    ''' 
        creates one interval tree for quick lookups
        returns 
            fragmentsMap[fragmentId] = [tuple(chrom, fragmentMidPoint)]
            intersect_tree - intersect Tree for interval matching
        
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : populate intervaltree from fragmented genome" % (timeStamp())
    
    intersect_tree = IntervalTree()
    fragmentsCount = 0
    fragmentsMap = {}
    
    start = 0
    end = 0
    counter = 0
    chrom = ""
    
    for line in fileinput.input([options.fragmentFile]):
        line = line.strip()
        if (len(line)==0 or line.startswith("Genome") or line.startswith("Chromosome")):
            continue
            
        cols = line.split("\t")
        try:
            # check if chromosome changed from last
            if (cols[0] != chrom):
                # do we have do finish the last chromosome?
                if (end > 0):
                    interval = Interval(chrom, start, end)
                    intersect_tree.insert(interval, fragmentsCount)
                    fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
                    fragmentsCount += 1
                    if (options.vverbose):
                        print >> sys.stdout,  "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
                # check if chromosome needs to be filtered out or not
                if (options.chromPattern  != "" and not re.match(options.chromPattern, cols[0])):
                    chrom = ""
                    start = 0
                    end = 0

                else:
                    chrom = cols[0]
                    start = int(cols[1])
                    end = int(cols[2])
                counter = 0
    
            # check if fragment aggregation is fulfilled
            elif (counter >= options.fragmentAggregation):
                interval = Interval(chrom, start, end)
                intersect_tree.insert(interval, fragmentsCount)
                if (options.vverbose):
                    print >> sys.stdout,  "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
    
                fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
                start = int(cols[1])
                end = int(cols[2])
                counter = 0
                fragmentsCount += 1                
            else:
                end = int(cols[2])
                
            # increment counter
            counter += 1
        
        except:
            if (options.verbose):
                print >> sys.stderr, 'skipping line in options.fragmentFile: %s' % (line)
            if (options.vverbose):
                traceback.print_exc()
                sys.exit(1)
    
    
    # handle last fragment
    if (end > 0):
        interval = Interval(chrom, start, end)
        intersect_tree.insert(interval, fragmentsCount)
        fragmentsMap[fragmentsCount] = tuple([chrom, int(0.5*(start+end))])
        fragmentsCount += 1
        if (options.vverbose):
            print >> sys.stdout, "-- intervaltree.add %s:%d-%d" % (chrom, start, end)
    
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: intervaltree populated" % (timeStamp())
            
    return [fragmentsMap, intersect_tree, fragmentsCount]

def getNext(iterator):
    ''' 
    get the next read and populate object
    '''
    
    try:
        return Read(iterator.next())
    except StopIteration:
        if (options.vverbose):
            traceback.print_exc()
        return Read("")
        
        
def findNextReadPair(samiter):
    ''' 
    find the next read pair
    '''
    readpair=[getNext(samiter), getNext(samiter)]
    
    while( re.sub('\/[1,2]$', '', readpair[0].qname) != re.sub('\/[1,2]$', '', readpair[1].qname)):
        if (options.verbose):
            print "[WARN] File: drop first from unpaired read %s %s" %(readpair[0].qname, readpair[1].qname)
        readpair.pop(0)
        readpair.append(getNext(samiter))
        
    return readpair
   
def find(interval, tree):
    ''' Returns a list with the overlapping intervals '''
    out = []
    tree.intersect( interval, lambda x: out.append(x) )
    return [ (x.start, x.end, x.linenum) for x in out ]
          

def getFragment(samfile, read, intersect_tree, fragmentList):
    fragmentID = -1
    try:
        # get fragments for both reads
                
        rchrom = samfile.getrname(read.tid)
        rstart = read.pos
        rend =  read.pos+read.alen

        if (options.vverbose):
            print >> sys.stdout, "- Check   : read %s %d %d" % (rchrom, rstart, rend )
        
        interval = Interval(rchrom, rstart, rend)

        fragments = find(interval, intersect_tree)
        if (len(fragments) == 0 ):
            if (options.vverbose):
                print >> sys.stderr, '[WARN] no overlap found : %s (skipping)' % (read)    
            return
        elif (len(fragments)> 1):
            if (not options.multicount):
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s (skipping)' % (read)    
                return 
            else:
                if (options.vverbose):
                    print >> sys.stderr, '[WARN] adding multiple fragments > 1 : %s (multicounting %d times)' % (read, len(fragments))    
                
        for i in xrange(len(fragments)):
            #extract fragmentID
            fragmentID = fragments[i][2] # corresponds to linenum
            
            if (not fragmentList.has_key(fragmentID)):
                fragmentList[fragmentID] = 0
    
            fragmentList[fragmentID] += 1
        
    except:
        if (options.verbose):
            print >> sys.stderr, '[WARN] problems with interval intersection: %s (skipping)' % (read)        
            traceback.print_exc()
            sys.exit(1)
        if (options.vverbose):
            traceback.print_exc()
            sys.exit(1)
            
    return fragmentID

def countReadsPerFragment(intersect_tree):
    '''
        counts the reads per fragment and generates appropriate output files
    '''
    
    fragmentList={}
    fragmentPairs = {}
    
    for bamFile in xrange(len(args)):
        if (options.verbose):
            print >> sys.stdout, "- %s START   : processing reads from bam file: %s" % (timeStamp(), args[bamFile])

        samfile = pysam.Samfile(args[bamFile], "rb" )
    
        samiter = samfile.fetch(until_eof=True)
        
        readcounter = 0
        
        while(True):
            readpair = findNextReadPair(samiter)
            # if file contains any more reads, exit
            if (readpair[0].qname=="dummy"):
                break
            
            fragmentID1 = getFragment(samfile, readpair[0], intersect_tree, fragmentList)
            fragmentID2 = getFragment(samfile, readpair[1], intersect_tree, fragmentList)
            
            if (fragmentID1 == None or fragmentID2 == None):
                if (options.vverbose):
                    print >> sys.stdout, "-- one read does not co-occur with any fragment: %d %d" % (fragmentID1, fragmentID2)
                continue
            elif (fragmentID1 == fragmentID2):
                if (options.vverbose):
                    print >> sys.stdout, "-- skip intra-fragment link: %d == %d" % (fragmentID1, fragmentID2)
                continue
    
        
            f_tuple = tuple([min(fragmentID1, fragmentID2), max(fragmentID1, fragmentID2)])
            if (not fragmentPairs.has_key(f_tuple)):
                fragmentPairs[f_tuple] = 0
            fragmentPairs[f_tuple] += 1
            readcounter+=1
            
            if (options.verbose and readcounter % 1000000 == 0 ):
                print >> sys.stdout, "- %s         : %d read pairs processed" % (timeStamp(), readcounter)
        samfile.close()
    
        if (options.verbose):
            print >> sys.stdout, "- %s FINISHED: getting reads from bam file " % (timeStamp())

    return [ fragmentList, fragmentPairs ]    


def output(fragmentsMap , fragmentList, fragmentPairs, fragmentCount):
    '''
    outputs 2 files, the first containing 
    "chr    extraField      fragmentMid     marginalizedContactCount        mappable? (0/1)"
    
    and the second containing:
    "chr1   fragmentMid1    chr2    fragmentMid2    contactCount"
    
    optionally output the 2D contact matrix
    '''
    
    if (options.verbose):
        print >> sys.stdout, "- %s START   : output data " % (timeStamp())

    if ( options.outputFilename != "" ):
        outfile1 = open(options.outputDir+options.outputFilename+".fragmentLists","w")    
    else:
        outfile1 = open(options.outputDir+os.path.basename(args[0])+".fragmentLists","w")
    
    fragmentIds = fragmentsMap.keys()
    fragmentIds.sort()

    # lookup mean mappability ratio
    bw = ""
    if (options.mappability != ""):
        # lazy load
        from bx.intervals.io import GenomicIntervalReader
        from bx.bbi.bigwig_file import BigWigFile
        bw = BigWigFile( open( options.mappability ) )
    

    for fragmentId in fragmentIds:

        mappable = 0
        contactCounts = 0
        chrom = fragmentsMap[fragmentId][0]
        midpoint =  fragmentsMap[fragmentId][1]

        if (options.vverbose):
            print >> sys.stdout, "- process %s %d " % (chrom, midpoint)

        if (fragmentList.has_key(fragmentId)):
            contactCounts = fragmentList[fragmentId]
        
        if (bw != ""):    
            try:
                mappable = bw.query(chrom, midpoint-options.resolution/2, midpoint+options.resolution/2, 1)[0]["mean"]
            except:
                # problem with invalid values
                if (options.vverbose):
                    print >> sys.stderr, "Problem with bw file at %s %d-%d" % (chrom, midpoint-options.resolution/2, midpoint+options.resolution/2)
                    print traceback.format_exc()
                
        elif (contactCounts>0):
            mappable=1

        outfile1.write("%s\t%d\t%s\t%f\n" % (chrom, midpoint, "NA", mappable))
        
    outfile1.close()
    
    if ( options.outputFilename != "" ):
        outfile2 = open(options.outputDir+options.outputFilename+".contactCounts","w")
    else:
        outfile2 = open(options.outputDir+os.path.basename(args[0])+".contactCounts","w")        
        
    for fragmentIds, contactCounts in fragmentPairs.iteritems():
        chrom1 = fragmentsMap[fragmentIds[0]][0]
        midpoint1 =  fragmentsMap[fragmentIds[0]][1]
    
        chrom2 = fragmentsMap[fragmentIds[1]][0]
        midpoint2 =  fragmentsMap[fragmentIds[1]][1]
    
        outfile2.write("%s\t%d\t%s\t%d\t%d\n" % (chrom1, midpoint1, chrom2, midpoint2, contactCounts))
        
    outfile2.close()
    
    if (options.create2DMatrix):

        # lazy loading
        from scipy.sparse import lil_matrix
        import numpy
        # populate sparse matrix
        A = lil_matrix((fragmentCount, fragmentCount), dtype='i')    
        for fragmentIds, contactCounts in fragmentPairs.iteritems():
            A[fragmentIds[0],fragmentIds[1]] = contactCounts
            A[fragmentIds[1],fragmentIds[0]] = contactCounts
            
        if ( options.outputFilename != "" ):
            outfile3 = options.outputDir+options.outputFilename+".matrix"
        else:
            outfile3 = options.outputDir+os.path.basename(args[0])+".matrix"

        if (options.verbose):
            print >> sys.stdout, "- save 2Dmatrix to %s " % (outfile3)
        
        f_handle=open(outfile3,'w')
        
        A = A.tocsr()
        for i in xrange(fragmentCount):
            numpy.savetxt(f_handle, A[i].toarray(),fmt='%i', delimiter='\t')
            
        f_handle.close()
        
    if (options.verbose):
        print >> sys.stdout, "- %s FINISHED: output data" % (timeStamp())


def process():
    global options
    global args

    if (options.fragmentFile != ""):    
        [ fragmentsMap, intersectTree, fragmentCount ] = createIntervalTreesFragmentFile()
    else:
        [ fragmentsMap, intersectTree, fragmentCount ] = createIntervalTreesFragmentResolution()
        
    [ fragmentList, fragmentPairs ] = countReadsPerFragment(intersectTree)
    
    output(fragmentsMap, fragmentList, fragmentPairs, fragmentCount)
    
######################################
# main
######################################
if __name__ == "__main__":
    main()

